{
  "version": 3,
  "sources": [
    "../../../.node/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "src/filter_exif.js",
    "src/filter_jpeg.js",
    "src/script.js"
  ],
  "names": [],
  "mappings": "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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\n'use strict';\n\n\nfunction error(message, code) {\n  let err = new Error(message);\n\n  err.code = code;\n\n  return err;\n}\n\n\n/* eslint-disable no-bitwise */\nfunction Exif(data) {\n  this.data = data;\n\n  let sig = String.fromCharCode.apply(null, data.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  }\n\n  this.big_endian = (sig[0] === 'M');\n}\n\n\nExif.prototype.readUInt16 = function (buffer, offset) {\n  if (offset + 2 > buffer.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n         buffer[offset] * 0x100 + buffer[offset + 1] :\n         buffer[offset] + buffer[offset + 1] * 0x100;\n};\n\n\nExif.prototype.readUInt32 = function (buffer, offset) {\n  if (offset + 4 > buffer.length) throw error('unexpected EOF', 'EBADDATA');\n\n  return this.big_endian ?\n         buffer[offset] * 0x1000000 + buffer[offset + 1] * 0x10000 + buffer[offset + 2] * 0x100 + buffer[offset + 3] :\n         buffer[offset] + buffer[offset + 1] * 0x100 + buffer[offset + 2] * 0x10000 + buffer[offset + 3] * 0x1000000;\n};\n\n\nExif.prototype.writeUInt16 = function (buffer, data, offset) {\n  // this could happen if TIFF is hand-crafted to be smaller than sum of its entries,\n  // and we wrongly allocate a smaller buffer than necessary\n  if (offset + 2 > buffer.length) throw error('TIFF data is too large', 'EBADDATA');\n\n  if (this.big_endian) {\n    buffer[offset]     = (data >>> 8) & 0xFF;\n    buffer[offset + 1] = data & 0xFF;\n  } else {\n    buffer[offset]     = data & 0xFF;\n    buffer[offset + 1] = (data >>> 8) & 0xFF;\n  }\n};\n\n\nExif.prototype.writeUInt32 = function (buffer, data, offset) {\n  // this could happen if TIFF is hand-crafted to be smaller than sum of its entries,\n  // and we wrongly allocate a smaller buffer than necessary\n  if (offset + 4 > buffer.length) throw error('TIFF data is too large', 'EBADDATA');\n\n  if (this.big_endian) {\n    buffer[offset]     = (data >>> 24) & 0xFF;\n    buffer[offset + 1] = (data >>> 16) & 0xFF;\n    buffer[offset + 2] = (data >>> 8) & 0xFF;\n    buffer[offset + 3] = data & 0xFF;\n  } else {\n    buffer[offset]     = data & 0xFF;\n    buffer[offset + 1] = (data >>> 8) & 0xFF;\n    buffer[offset + 2] = (data >>> 16) & 0xFF;\n    buffer[offset + 3] = (data >>> 24) & 0xFF;\n  }\n};\n\n\n// Filter exif data and write it into a buffer\n//\n// - options: Object\n//   - maxEntrySize: Number\n//   - onIFDEntry: Function\n// - out: Uint8Array - a buffer to write exif to\n//\n// `maxEntrySize` meaning: when filtering Exif, remove all fields with size\n// more than `maxEntrySize`. Note that most useful data in Exif is stored as\n// integers (<= 12 bytes), so setting it higher will only filter out comments\n// and vendor crap (default: 100 bytes)\n//\n// `onIFDEntry` is called on each entry inside IFD (think about Exif being\n// an array of IFDs, and IFD being an array of entries). You may return `false`\n// to filter out said element from Exif.\n//\n// `onIFDEntry` function signature:\n//\n//  - ifd: Number\n//    - 0x0000 for IFD0\n//    - 0x0001 for IFD1 (not currently supported)\n//    - 0x8825 for GPSIFD\n//    - 0x8769 for ExifIFD\n//    - 0xA005 for InteropIFD\n//\n//  - entry: Object - the contents of the IFD entry\n//    - tag:   Number - data tag\n//    - type:  Number - data type (short, double, ascii, etc., see details in TIFF spec)\n//    - count: Number - an amount of items in buffer (see details in TIFF spec)\n//    - value: Buffer - data buffer (use this.readUint16 or this.readUint32 to read from there)\n//\n// Example:\n//\n// ```js\n// onIFDEntry: function readOrientation(ifd, entry) {\n//   if (ifd === 0 && entry.tag === 0x112 && entry.type === 3) {\n//     console.log('Orientation =', this.readUInt16(entry.value, 0));\n//   }\n// }\n// ```\n//\nExif.prototype.filter = function (options, out) {\n  let maxSize = options && options.maxEntrySize ? options.maxEntrySize : 100;\n\n  /* eslint-disable func-style */\n  const filter_entry = sectionName => entry => {\n    if (options && options.onIFDEntry) {\n      if (options.onIFDEntry.call(this, sectionName, entry) === false) {\n        return false;\n      }\n    }\n\n    return entry.value.length <= maxSize;\n  };\n\n  this.output = {\n    buf: out,\n    length: 0\n  };\n\n  let offset = 0;\n\n  // copy signature (it's already checked on init)\n  this.output.buf[0] = this.data[0];\n  this.output.buf[1] = this.data[1];\n  this.output.buf[2] = this.data[2];\n  this.output.buf[3] = this.data[3];\n  this.output.length += 4;\n\n  this.writeUInt32(this.output.buf, 8, this.output.length);\n  this.output.length += 4;\n\n  offset = this.readUInt32(this.data, 4);\n\n  // We only do read IFD0 here, IFD1 is ignored\n  // because we don't need to preserve thumbnails\n  //\n  let t = this.processIFDSection(offset, filter_entry(0));\n\n  t.entries.forEach(entry => {\n    //                ExifIFD                 GPSIFD                interopIFD\n    if (entry.tag === 0x8769 || entry.tag === 0x8825 || entry.tag === 0xA005) {\n      if (entry.type === 4) {\n        this.writeUInt32(this.output.buf, this.output.length, entry.written_offset + 8);\n\n        let off = this.readUInt32(entry.value, 0);\n\n        this.processIFDSection(off, filter_entry(entry.tag));\n      }\n    }\n  });\n\n  // we wrote more data than we allocated buffer for,\n  // this could happen if TIFF is hand-crafted to be smaller than sum of its entries\n  //\n  if (this.output.length > this.output.buf.length) {\n    throw error('TIFF data is too large', 'EBADDATA');\n  }\n\n  return this.output.length;\n};\n\n\nExif.prototype.readIFDEntry = function (offset) {\n  let tag   = this.readUInt16(this.data, offset);\n  let type  = this.readUInt16(this.data, offset + 2);\n  let count = this.readUInt32(this.data, offset + 4);\n  let unit_length;\n\n  switch (type) {\n    case 1: // byte\n    case 2: // ascii\n    case 6: // sbyte\n    case 7: // undefined\n      unit_length = 1;\n      break;\n\n    case 3: // short\n    case 8: // sshort\n      unit_length = 2;\n      break;\n\n    case 4:  // long\n    case 9:  // slong\n    case 11: // float\n      unit_length = 4;\n      break;\n\n    case 5:  // rational\n    case 10: // srational\n    case 12: // double\n      unit_length = 8;\n      break;\n\n    default:\n      // unknown type, skipping\n      return;\n  }\n\n  let value;\n  let length = unit_length * count;\n\n  if (length <= 4) {\n    value = this.data.subarray(offset + 8, offset + 12);\n\n    if (value.length < 4) throw error('unexpected EOF', 'EBADDATA');\n  } else {\n    let offv = this.readUInt32(this.data, offset + 8);\n\n    value = this.data.subarray(offv, offv + length);\n\n    if (value.length < length) throw error('unexpected EOF', 'EBADDATA');\n  }\n\n  return { tag, type, count, value };\n};\n\n\nExif.prototype.processIFDSection = function (offset, filter) {\n  let entries_to_write = [];\n  let entries_count = this.readUInt16(this.data, offset);\n\n  offset += 2;\n\n  for (let i = 0; i < entries_count; i++) {\n    let entry = this.readIFDEntry(offset + i * 12);\n\n    if (!entry) continue;\n    if (!filter(entry)) continue;\n\n    entries_to_write.push(entry);\n  }\n\n  this.writeUInt16(this.output.buf, entries_to_write.length, this.output.length);\n  this.output.length += 2;\n\n  let written_ifb_offset = this.output.length;\n\n  entries_to_write.forEach(entry => {\n    entry.written_offset = this.output.length;\n\n    this.writeUInt16(this.output.buf, entry.tag, this.output.length);\n    this.writeUInt16(this.output.buf, entry.type, this.output.length + 2);\n    this.writeUInt32(this.output.buf, entry.count, this.output.length + 4);\n\n    if (entry.value.length <= 4) {\n      if (entry.value.length + this.output.length + 8 > this.output.buf.length) {\n        throw error('TIFF data is too large', 'EBADDATA');\n      }\n\n      this.output.buf.set(entry.value, this.output.length + 8);\n    }\n\n    this.output.length += 12;\n  });\n\n  this.writeUInt32(this.output.buf, 0, this.output.length);\n  this.output.length += 4;\n\n  entries_to_write.forEach((entry, i) => {\n    if (entry.value.length > 4) {\n      this.writeUInt32(this.output.buf, this.output.length, written_ifb_offset + i * 12 + 8);\n\n      if (entry.value.length + this.output.length > this.output.buf.length) {\n        throw error('TIFF data is too large', 'EBADDATA');\n      }\n\n      this.output.buf.set(entry.value, this.output.length);\n\n      this.output.length += entry.value.length;\n\n      if (this.output.length % 2) {\n        // ensure that everything is at word boundary\n        this.output.buf[this.output.length] = 0xFF;\n        this.output.length++;\n      }\n    }\n  });\n\n  return {\n    entries:  entries_to_write,\n    next_ifb: this.readUInt32(this.data, offset + entries_count * 12)\n  };\n};\n\n\nmodule.exports = function filter_exif(data, options) {\n  if (String.fromCharCode.apply(null, data.subarray(0, 6)) !== 'Exif\\0\\0') {\n    throw error('invalid Exif signature', 'ENOTEXIF');\n  }\n\n  // Create buffer of the same length as input.\n  //\n  // This is good enough for most of the cases, but will throw\n  // if exif is packed (referencing the same data multiple times)\n  //\n  let output  = new data.constructor(data.length);\n  let exif    = new Exif(data.subarray(6));\n\n  'Exif\\0\\0'.split('').forEach((c, pos) => {\n    output[pos] = c.charCodeAt(0);\n  });\n\n  // Write filtered exif into output at position 6,\n  // it's built around the fact that subarray copy is shallow\n  //\n  let length = exif.filter(options, output.subarray(6));\n\n  return new data.constructor(output.subarray(0, length + 6));\n};\n",
    "\n'use strict';\n\nconst filterExif  = require('./filter_exif');\n\n\n///////////////////////////////////////////////////////////////////////\n// JPEG parser\n//\n\n// Parser states\n//\nconst FILE_START          =  0; // start of the file, read signature (FF)\nconst FILE_START_FF       =  1; // start of the file, read signature (D8)\nconst SEGMENT_START       =  2; // start of a segment, expect to read FF\nconst SEGMENT_MARKER      =  3; // read marker ID\nconst SEGMENT_LENGTH      =  4; // read segment length (2 bytes total)\nconst SEGMENT_IGNORE      =  5; // read segment and ignore it\nconst SEGMENT_PIPE        =  6; // read segment and pass it into output\nconst SEGMENT_PIPE_DATA   =  7; // read segment and pass it into output (data)\nconst SEGMENT_BUFFER      =  8; // buffer segment, process as exif\nconst SEGMENT_BUFFER_DATA =  9; // buffer segment, process as exif\nconst IMAGE               = 10; // start reading image\nconst IMAGE_FF            = 11; // process possible segment inside image\nconst FINAL               = 12; // ignore the rest of the data\n\n\n/* eslint-disable no-bitwise */\nfunction JpegFilter(options) {\n  if (!(this instanceof JpegFilter)) return new JpegFilter(options);\n\n  options = options || {};\n\n  this.output = [];\n\n  this._state = FILE_START;\n\n  //\n  // Parser options\n  //\n\n  // remove ICC profile (2-10 kB)\n  this._removeICC        = options.removeICC;\n\n  // `true` - remove Exif completely, `false` - filter it and remove thumbnail\n  this._removeExif       = options.removeExif;\n\n  // remove other meta data (XMP, Photoshop, etc.)\n  this._filter           = options.filter;\n\n  // remove JPEG COM segments\n  this._removeComments   = options.removeComments;\n\n  // remove the rest of the image (everything except metadata);\n  // if it's `true`, output will be a series of segments, and NOT a valid jpeg\n  this._removeImage      = options.removeImage;\n\n  // add a comment at the beginning of the JPEG\n  // (it's added after JFIF, but before anything else)\n  this._comment          = options.comment;\n\n  // exif options (passed for exif parser as is)\n  this._maxEntrySize     = options.maxEntrySize;\n  this._onIFDEntry       = options.onIFDEntry;\n\n  // internal data\n  this._Buffer           = null;\n  this._markerCode       = 0;\n  this._bytesLeft        = 0;\n  this._segmentLength    = 0;\n  this._app1buffer       = null;\n  this._app1pos          = 0;\n  this._bytesRead        = 0;\n}\n\n\nfunction toHex(number) {\n  let n = number.toString(16).toUpperCase();\n\n  for (let i = 2 - n.length; i > 0; i--) n = '0' + n;\n\n  return '0x' + n;\n}\n\n\n// Perform a shallow copy of a buffer or typed array\n//\nfunction slice(buf, start, end) {\n  if (buf.slice && buf.copy && buf.writeDoubleBE) {\n    //\n    // Looks like node.js buffer\n    //\n    // - we use buf.slice() in node.js buffers because\n    //   buf.subarray() is not a buffer\n    //\n    // - we use buf.subarray() in uint8arrays because\n    //   buf.slice() is not a shallow copy\n    //\n    return buf.slice(start, end);\n  }\n\n  return buf.subarray(start, end);\n}\n\n\n// Copy one buffer to another\n//\nfunction copy(src, dst, dst_offset) {\n  if (src.length + dst_offset > dst.length) throw new Error('buffer is too small');\n\n  if (src.copy) {\n    src.copy(dst, dst_offset);\n  } else {\n    dst.set(src, dst_offset);\n  }\n}\n\n\nJpegFilter.prototype._error = function (message, code) {\n  // double error?\n  if (this._state === FINAL) return;\n\n  let err = new Error(message);\n\n  err.code = code;\n\n  this._state = FINAL;\n  this.onError(err);\n};\n\n\n/* eslint-disable max-depth */\nJpegFilter.prototype.push = function (data) {\n  if (!this._Buffer) this._Buffer = data.constructor;\n\n  var buf, di, i = 0;\n\n  while (i < data.length) {\n    let b = data[i];\n\n    switch (this._state) {\n      // start of the file, read signature (FF)\n      case FILE_START:\n        if (b !== 0xFF) {\n          this._error('unknown file format', 'ENOTJPEG', i);\n          return;\n        }\n\n        this._state = FILE_START_FF;\n        i++;\n        break;\n\n      // start of the file, read signature (D8)\n      case FILE_START_FF:\n        if (b !== 0xD8) {\n          this._error('unknown file format', 'ENOTJPEG', i);\n          return;\n        }\n\n        this.onData(new this._Buffer([ 0xFF, 0xD8 ]));\n        this._state = SEGMENT_START;\n        i++;\n        break;\n\n      // start of a segment, expect to read FF\n      case SEGMENT_START:\n        if (this._markerCode === 0xDA) {\n          // previous segment was SOS, so we should read image data instead\n          this._state = IMAGE;\n          break;\n        }\n\n        if (b !== 0xFF) {\n          this._error('unexpected byte at segment start: ' + toHex(b) +\n                      ' (offset ' + toHex(this._bytesRead + i) + ')',\n                      'EBADDATA');\n          return;\n        }\n\n        this._state = SEGMENT_MARKER;\n        i++;\n        break;\n\n      // read marker ID\n      case SEGMENT_MARKER:\n        // standalone markers, according to JPEG 1992,\n        // http://www.w3.org/Graphics/JPEG/itu-t81.pdf, see Table B.1\n        if ((0xD0 <= b && b <= 0xD9) || b === 0x01) {\n          this._markerCode = b;\n          this._bytesLeft = 0;\n          this._segmentLength = 0;\n\n          if (this._markerCode === 0xD9 /* EOI */) {\n            this.onData(new this._Buffer([ 0xFF, 0xD9 ]));\n            this._state = FINAL;\n            this.onEnd();\n          } else {\n            this._state = SEGMENT_LENGTH;\n          }\n\n          i++;\n          break;\n        }\n\n        // the rest of the unreserved markers\n        if (0xC0 <= b && b <= 0xFE) {\n          this._markerCode = b;\n          this._bytesLeft = 2;\n          this._segmentLength = 0;\n          this._state = SEGMENT_LENGTH;\n          i++;\n          break;\n        }\n\n        if (b === 0xFF) {\n          // padding byte, skip it\n          i++;\n          break;\n        }\n\n        // unknown markers\n        this._error('unknown marker: ' + toHex(b) +\n                    ' (offset ' + toHex(this._bytesRead + i) + ')',\n                    'EBADDATA');\n        return; // return after error, not break\n\n      // read segment length (2 bytes total)\n      case SEGMENT_LENGTH:\n        while (this._bytesLeft > 0 && i < data.length) {\n          this._segmentLength = this._segmentLength * 0x100 + data[i];\n          this._bytesLeft--;\n          i++;\n        }\n\n        if (this._bytesLeft <= 0) {\n          if (this._comment !== null && typeof this._comment !== 'undefined' && this._markerCode !== 0xE0) {\n            // insert comment field before any other markers (except APP0)\n            //\n            // (we can insert it anywhere, but JFIF segment being first\n            // looks nicer in hexdump)\n            //\n            let enc;\n\n            try {\n              // poor man's utf8 encoding\n              enc = unescape(encodeURIComponent(this._comment));\n            } catch (err) {\n              enc = this._comment;\n            }\n\n            buf = new this._Buffer(5 + enc.length);\n            buf[0] = 0xFF;\n            buf[1] = 0xFE;\n            buf[2] = ((enc.length + 3) >>> 8) & 0xFF;\n            buf[3] = (enc.length + 3) & 0xFF;\n\n            /* eslint-disable no-loop-func */\n            enc.split('').forEach((c, pos) => {\n              buf[pos + 4] = c.charCodeAt(0) & 0xFF;\n            });\n\n            buf[buf.length - 1] = 0;\n\n            this._comment = null;\n            this.onData(buf);\n          }\n\n          if (this._markerCode === 0xE0) {\n            // APP0, 14-byte JFIF header\n            this._state = SEGMENT_PIPE;\n          } else if (this._markerCode === 0xE1) {\n            // APP1, Exif candidate\n            this._state = this._filter && this._removeExif ?\n                          SEGMENT_IGNORE : // ignore if we remove both\n                          SEGMENT_BUFFER;\n          } else if (this._markerCode === 0xE2) {\n            // APP2, ICC_profile\n            this._state = this._removeICC ?\n                          SEGMENT_IGNORE :\n                          SEGMENT_PIPE;\n          } else if (this._markerCode > 0xE2 && this._markerCode < 0xF0) {\n            // Photoshop metadata, etc.\n            this._state = this._filter ?\n                          SEGMENT_IGNORE :\n                          SEGMENT_PIPE;\n          } else if (this._markerCode === 0xFE) {\n            // Comments\n            this._state = this._removeComments ?\n                          SEGMENT_IGNORE :\n                          SEGMENT_PIPE;\n          } else {\n            // other valid headers\n            this._state = this._removeImage ?\n                          SEGMENT_IGNORE :\n                          SEGMENT_PIPE;\n          }\n\n          this._bytesLeft = Math.max(this._segmentLength - 2, 0);\n        }\n        break;\n\n      // read segment and ignore it\n      case SEGMENT_IGNORE:\n        di = Math.min(this._bytesLeft, data.length - i);\n        i += di;\n        this._bytesLeft -= di;\n\n        if (this._bytesLeft <= 0) this._state = SEGMENT_START;\n        break;\n\n      // read segment and pass it into output\n      case SEGMENT_PIPE:\n        if (this._bytesLeft <= 0) {\n          this._state = SEGMENT_START;\n        } else {\n          this._state = SEGMENT_PIPE_DATA;\n        }\n\n        buf = new this._Buffer(4);\n        buf[0] = 0xFF;\n        buf[1] = this._markerCode;\n        buf[2] = ((this._bytesLeft + 2) >>> 8) & 0xFF;\n        buf[3] = (this._bytesLeft + 2) & 0xFF;\n        this.onData(buf);\n        break;\n\n      // read segment and pass it into output\n      case SEGMENT_PIPE_DATA:\n        di = Math.min(this._bytesLeft, data.length - i);\n        this.onData(slice(data, i, i + di));\n\n        i += di;\n        this._bytesLeft -= di;\n\n        if (this._bytesLeft <= 0) this._state = SEGMENT_START;\n        break;\n\n      // read segment and buffer it, process as exif\n      case SEGMENT_BUFFER:\n        this._app1buffer = new this._Buffer(this._bytesLeft);\n        this._app1pos    = 0;\n\n        this._state = SEGMENT_BUFFER_DATA;\n        break;\n\n      // read segment and buffer it, process as exif\n      case SEGMENT_BUFFER_DATA:\n        di = Math.min(this._bytesLeft, data.length - i);\n\n        let buf_slice = slice(data, i, i + di);\n\n        copy(buf_slice, this._app1buffer, this._app1pos);\n        this._app1pos += buf_slice.length;\n\n        i += di;\n        this._bytesLeft -= di;\n\n        if (this._bytesLeft <= 0) {\n          let buf = this._app1buffer;\n          this._app1buffer = null;\n\n          if (this._markerCode === 0xE1 /* APP1 */ &&\n              // compare with 'Exif\\0\\0'\n              buf[0] === 0x45 && buf[1] === 0x78 && buf[2] === 0x69 &&\n              buf[3] === 0x66 && buf[4] === 0x00 && buf[5] === 0x00) {\n\n            // EXIF\n            if (this._removeExif) {\n              buf = null;\n            } else {\n              try {\n                buf = filterExif(buf, {\n                  maxEntrySize: this._maxEntrySize,\n                  onIFDEntry:   this._onIFDEntry\n                });\n              } catch (err) {\n                buf = null;\n\n                // unexpected errors inside EXIF parser\n                if (err.code && err.code !== 'EBADDATA') {\n                  this.onError(err);\n                  return;\n                }\n              }\n            }\n          } else {\n            // not EXIF, maybe XMP\n            /* eslint-disable no-lonely-if */\n            if (this._filter === true) buf = null;\n          }\n\n          if (buf) {\n            let buf2 = new this._Buffer(4);\n\n            buf2[0] = 0xFF;\n            buf2[1] = this._markerCode;\n            buf2[2] = ((buf.length + 2) >>> 8) & 0xFF;\n            buf2[3] = (buf.length + 2) & 0xFF;\n\n            this.onData(buf2);\n            this.onData(buf);\n          }\n\n          this._state = SEGMENT_START;\n        }\n        break;\n\n      // read image until we get FF\n      case IMAGE:\n        let start = i;\n\n        while (i < data.length) {\n          if (data[i] === 0xFF) {\n            if (i + 1 < data.length) {\n              b = data[i + 1];\n\n              // skip FF and restart markers\n              if (b === 0x00 || b >= 0xD0 && b < 0xD8) {\n                i += 2;\n                continue;\n              }\n            }\n\n            break;\n          }\n\n          i++;\n        }\n\n        if (!this._removeImage) {\n          this.onData(slice(data, start, i));\n        }\n\n        if (i < data.length) {\n          this._state = IMAGE_FF;\n          i++;\n        }\n        break;\n\n      // process possible segment inside image\n      case IMAGE_FF:\n        // 00 - escaped FF, D0-D7 - restart markers, FF - just padding\n        if (b === 0x00 || (b >= 0xD0 && b < 0xD8) || b === 0xFF) {\n          if (!this._removeImage) {\n            this.onData(new this._Buffer([ 255, b ]));\n          }\n\n          this._state = (b === 0xFF ? IMAGE_FF : IMAGE);\n          i++;\n          break;\n        }\n\n        this._state = SEGMENT_MARKER;\n        break;\n\n      // ignore the rest of the data\n      case FINAL:\n        break;\n    }\n  }\n\n  this._bytesRead += data.length;\n};\n\n\nJpegFilter.prototype.end = function () {\n  switch (this._state) {\n    case FILE_START:\n    case FILE_START_FF:\n    case SEGMENT_IGNORE:\n    case SEGMENT_PIPE:\n    case SEGMENT_PIPE_DATA:\n    case SEGMENT_BUFFER:\n    case SEGMENT_BUFFER_DATA:\n      // in those 6 states arbitrary data of a fixed length\n      // is expected, and we didn't get any\n      //\n      this._error('unexpected end of file' +\n                  ' (offset ' + toHex(this._bytesRead) + ')',\n                  'EBADDATA');\n      break;\n\n    case FINAL:\n      break;\n\n    default:\n      // otherwise just simulate EOI segment\n      //\n      this.push(new this._Buffer([ 0xFF, 0xD9 ]));\n  }\n};\n\n\nJpegFilter.prototype.onData = function (chunk) {\n  this.output.push(chunk);\n};\n\n\nJpegFilter.prototype.onEnd = function () {\n};\n\n\nJpegFilter.prototype.onError = function (err) {\n  throw err;\n};\n\n\n///////////////////////////////////////////////////////////////////////\n// Exports\n//\nmodule.exports = JpegFilter;\n",
    "function fileHandler (event) {\n  event.preventDefault();\n\n  event = event.originalEvent || event;\n\n  var target = event.dataTransfer || event.target;\n\n  var fileOrBlob = target && target.files && target.files[0];\n\n  if (!fileOrBlob) {\n    return;\n  }\n\n  loadImage.parseMetaData(fileOrBlob, function (data) {\n    if (!data.imageHead) {\n      console.error('No image header', fileOrBlob);\n      return;\n    }\n\n    console.log(data);\n\n    console.log(data.exif.getAll());\n\n    loadImage(fileOrBlob, function (resizedImageCanvas) {\n      resizedImageCanvas.toBlob(function (resizedBlob) {\n        // // Do something with the blob object,\n        // // e.g. creating a multipart form for file uploads:\n        // var formData = new FormData();\n        // formData.append('file', blob, fileName);\n        // /* ... */\n\n        // Combine data.imageHead with the image body of a resized file\n        // to create scaled images with the original image meta data, e.g.:\n        var blob = new Blob([\n          data.imageHead,\n          // Resized images always have a head size of 20 bytes,\n          // including the JPEG marker and a minimal JFIF header:\n          loadImage.blobSlice.call(resizedBlob, 20),\n        ], {\n          type: resizedBlob.type,\n        });\n\n        console.log(blob);\n\n        saveAs(blob, 'image.jpg');\n\n      },\n        'image/jpeg'\n      );\n\n    }, {\n      maxWidth: 500,\n      maxHeight: 500,\n      canvas: true,\n    });\n\n  }, {\n    maxMetaDataSize: 262144,\n    disableImageHead: false,\n  }\n  );\n}\n\nvar filter_jpeg = require('./filter_jpeg');\n\nfunction fileHandler2 (event) {\n  event.preventDefault();\n\n  event = event.originalEvent || event;\n\n  var target = event.dataTransfer || event.target;\n\n  var fileOrBlob = target && target.files && target.files[0];\n\n  if (!fileOrBlob) {\n    return;\n  }\n\n  var reader = new FileReader();\n\n  reader.onloadend = () => {\n    var fileData = new Uint8Array(reader.result);\n\n    if (fileData[0] === 0xFF && fileData[1] === 0xD8) {\n      // only keep comments and exif in header\n      var filter = filter_jpeg({\n        removeImage: true,\n        filter: true,\n        removeICC: true\n      });\n\n      try {\n        filter.push(fileData);\n        filter.end();\n      } catch (err) {\n        // reject(new Error(err));\n        return;\n      }\n\n      var tmp = arrayConcat(filter.output);\n\n      // cut off last 2 bytes (EOI, 0xFFD9),\n      // they are always added by filter_jpeg on end\n      var jpegHeader = tmp.subarray(0, tmp.length - 2);\n    }\n\n    var imgSrc = window.URL.createObjectURL(fileOrBlob);\n\n    console.log(imgSrc);\n  };\n\n  reader.readAsArrayBuffer(fileOrBlob);\n}\n\ndocument.getElementById('file-input').addEventListener('change', fileHandler2);\n"
  ]
}